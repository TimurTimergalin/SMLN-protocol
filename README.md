# Спецификация протокола "Secure Messaging in Local Network" (SMLN) v1.0

## Введение

*Протокол безопасного обмена сообщениями в локальной сети  (Secure Messaging in Local Network, SMLN)* - протокол прикладного уровня для систем мгновенного обмена сообщениями с клиент-серверной архитектурой в локальной сети (*LAN*).

## Предназначение

Протокол `SMLN` описывает безопасный способ передачи и хранения сообщений между пользователями локальной сети.

## Терминология

**Администратор** - лицо, отвечающее за внедрение и обслуживание сервера, а также за предоставление пользователям доступ к клиенту (клиентам).

**База данных** - совокупность средств, использующихся сервером для *постоянного* хранения данных (СУБД, файловая система и т.п.).

**Запрос** - сообщение от клиента серверу.

**Клиент** - интерфейс, через который пользователь взаимодействует с системой обмена сообщениями (консольное приложение, настольное приложение, веб-интерфейс).

**Конфиденциальная информация о пользователе** - совокупность всех данных пользователя, которые *не могут* быть включены в публичную информацию о пользователе.

**Ответ** - сообщение, отправляемое сервером клиенту в ответ на запрос.

**Пользователь** - участник локальной сети, осуществляющий общение с другими пользователями через *сервер*.

**Пользовательское сообщение** - текст, который один пользователь хочет отправить другому.

**Публичная информация о пользователе** - совокупность всех данных о пользователе, которые каждый авторизированный пользователь может получить, послав соответствующий запрос на сервер. 

**Сервер** - участник локальной сети, осуществляющий непосредственный обмен данными между пользователями, а также отвечающий за хранение информации.

**Система (мгновенного) обмена сообщениями** - совокупность устройств и программ, использующихся для обмена информацией между пользователями.

**Событие** - сообщение от сервера клиенту(там), не инициированное запросом клиента.

**Сообщение** - текст, отправленный клиентом серверу или наоборот по протоколу `ws`.

## Возможности

Система мгновенного обмена сообщениями, использующая протокол `SMLN`, позволяет пользователям:

- Отправлять другим пользователям текстовые сообщения;
- Отправлять другим пользователям файлы;
- Просматривать историю общения с каждым пользователем (частично).

## Описание протокола

### Клиент

#### Установка соединения

Для начала обмена сообщениями по протоколу `SMLN` пользователь должен установить соединение с сервером. Обмен сообщениями с сервером осуществляется по протоколу `ws` (*WebSocket*), алгоритм установки соединения описан в *RFC 6455*.

Так как сообщения, сформированные по протоколу `SMLN`, содержат конфиденциальную информацию, клиенту ***необходимо*** удостовериться, что используется защищенная версия протокола `ws` - `wss`,- снабжённая криптографическим протоколом *TSL*. 

#### Регистрация в системе/Создание аккаунта

Протокол `SMNL` не предоставляет унифицированного интерфейса для регистрации в системе. Это связано с тем, что возможность пользователей свободно создавать аккаунты может быть нежелательным для защищенной системы обмена сообщений (например, недобросовестный пользователь системы может попытаться выдать себя за другого пользователя, создав аккаунт с похожим именем). 

На сервере может присутствовать интерфейс свободной регистрации, но его реализация не ограничивается протоколом `SMLN`. Чтобы узнать, как зарегистрироваться в системе, пользователю необходимо обратиться к администратору.   

#### Авторизация в системе

Чтобы пользователь мог пользоваться всеми возможностями API сервера, он должен сообщить серверу свои данные - логин и пароль. В `SMLN` для этого используется запрос типа `auth`.

#### Дальнейший обмен сообщениями

После авторизации пользователь может свободно использовать API сервера в рамках одного подключения.

#### Отключение от сети

Прекращение соединения происходит по правилам протокола `ws`. 

#### Хранение информации

Все пользовательские сообщения и файлы на сервере хранятся в зашифрованном виде. Для шифрования используются пара *RSA*-ключей, а также пароль пользователя (пароль не храниться на сервере в незашифрованном виде, но становится известен серверу в рамках одного подключения после авторизации). Так как регулярная смена пароля и *RSA*-ключей является общепринятой практикой для их защиты от компрометации, данные не могут храниться на сервере в течение неограниченного времени - после смены пароля или ключей данные невозможно будет расшифровать, а значит доступ к ним будет утерян. 

Таким образом, система обмена сообщениями, использующая протокол `SMLN`, ***не предназначена для долгосрочного хранения данных***. Возможность просмотреть историю пользовательских сообщений создана исключительно для удобства пользователей. Пара *RSA*-ключей может быть изменена в любой момент по усмотрению сервера, поэтому доступ к ранее отправленным и полученным пользовательским сообщениям могут быть утеряны в любой момент без возможности пользователя на это повлиять. Протокол `SMLN` создан для обмена сообщениями, а не для их хранения.

### Сервер

#### Требования к WebSocket-соединению

Сервер, использующий протокол `SMLN`, должен предоставлять свой API с помощью протокола `ws` (*WebSocket*).

Так как сообщения, сформированные по протоколу `SMLN`, содержат конфиденциальную информацию,***необходимо*** использовать защищённую версию протокола `ws` - `wss`,- снабжённую криптографическим протоколом *TSL*.

Для защиты от атак вида *Cross-Site WebSocket Hijacking* (*Crsf-атаки* во время *WebSocket-рукопожатия*), ***настоятельно рекомендуется*** проверять значение заголовка `Origin` во время рукопожатия.

#### Хранение данных пользователей

У каждого аккаунта должны быть *идентификатор*, *логин* и *пароль*.

*Идентификатор* - уникальное числовое значение, однозначно задающая пользователя. Идентификатор является публичной информацией о пользователе. Любой авторизованный пользователь должен иметь возможность получить информацию о пользователе по его идентификатору.  Идентификаторы могут храниться в базе данных в открытом виде.

*Логин* используется для авторизации в систему. Логины у разных пользователей должны быть уникальны. Логин может как быть, так и не быть публичной информацией о пользователе. Логины могут храниться в базе данных в открытом виде.

*Пароль* используется для авторизации, а также для получения *охранного ключа*. Пароль может храниться в базе данных **только в захэшированном виде**. Способ шифрования не ограничивается протоколом `SMLN`. Пароль (в любом виде) является конфиденциальной информацией о пользователе.

Для каждого пользователя можно вычислить *охранный ключ* - для этого нужно применить хэш-функцию к паролю пользователя (хэш-функция должна отличаться от той, что используется для хранения пароля в базе данных), а затем полученное значение преобразовать в корректный ключ для шифрования *AES256*. Охранный ключ **не может быть сохранён** в базе данных ни в каком виде. Охранный ключ (в любом виде) явлется конфиденциальной информацией о пользователе.

Каждому пользователю должна быть присвоена пара *RSA*-ключей - *открытый* и *закрытый* ключи.

*Открытый ключ* используется для шифрования пользовательских сообщений, предназначенных владельцу ключа. *Открытый ключ* является публичной информацией о пользователе. Публичный ключ может храниться в базе данных в открытом виде.

*Закрытый ключ* используется для дешифрования пользовательских сообщений, полученных владельцем ключа. Для хранения в базе данных ключ должен быть зашифрован *охранным ключом* с помощью *AES256*. Закрытый ключ (в любом виде) является конфиденциальной информацией о пользователе.

Сервер может поменять пару ключей в любое время, когда ему известен незашифрованный пароль (например, при смене пароля администратором или подключении пользователя).

#### Шифрование пользовательских сообщений/содержимого файлов  

Перед сохранением на сервер все пользовательские сообщения/файлы должны быть зашифрованы двумя ключами - открытым ключом отправителя и открытым ключом получателя. Храниться должна каждая из двух зашифрованных копий.

При запросе пользователем информации о пользовательском сообщении/файле сервер должен найти соответствующую пользователю зашифрованную копию, дешифровать ее закрытым ключом пользователя (для этого серверу должен быть известен пароль пользователя, пароль не должен храниться на сервере! незашифрованный пароль может храниться в переменной среды исполнения кода сервера) и отправить пользователю.

## Формат сообщений

Сообщение, сформированное по протоколу `SMLN` представляет собой объект `JSON`, сериализованный в строку. Каждое сообщение имеет *тип*, который обязан быть указан в поле сообщения `"type"`. В случае, если в запросе передаются дополнительные аргументы, они должны храниться в поле сообщения `"args"` как `JSON` объект.

Если запрос клиента предполагает ответ, то сервер обязан его отправить. Ответ должен иметь тот же *тип*, что и запрос, и снабжен статусом выполнения запроса, который должен храниться в поле `"status"`.

Ответы и события не могут содержать конфиденциальной информации о каких-либо пользователях.

###  Обработка ошибок

Каждый ответ серевера должен содержать статус выполнения запроса, представленный в виде числового значения. Возможные статусы представлены ниже:

- 0 - успешный запрос
- 1 - ошибка клиента - неверный формат/тип запроса
- 2 - ошибка клиента - некорректные аргументы
- 3 - ошибка клиента - доступ запрещен
- 4 - ошибка клиента - неверные данные авторизации
- 5-19 - зарезервированы для ошибок клиента в будущих версиях `SMLN`
- 20 - ошибка сервера
- 21-127 - ошибки, определяемые сервером

В случае, если при выполнении запроса произошла ошибка, значение поля *args* в ответе должно отсутствовать или быть пустым.

### Типы и объекты

Далее представлены различные типы, использующиеся в описании формата сообщений.

#### Стандартные типы данных json

- *int* - целое число
- *float* - число с плавающей точкой
- *bool* - значение логического типа (*true/false*)
- *string* - строка

#### unixtime

**unixtime** - целочисленное значение *Unix-времени*.

#### response-status

Тип *response-status* содержит информацию о результате выполнения запроса клиента. *response-status* должен содержать код статуса (поле `"status"`). *response-status* также может содержать описание ошибки, произошедшей во время выполнения запроса (поле `"error-message"`). Правило составления описания ошибки не ограничивается протоколом `SMLN`.

```
{
    "status": <int>,
    "error-message": <string>
}
```

#### user

Тип *user* используется для представления публичной информации о пользователе. Публичная информация должна включать в себя *идентификатор пользователя* (поле `"id"`) и *открытый ключ* (поле `"public-key"`). Публичная информация пользователя может включать и другие поля (это определяется сервером).

```
{
    "id": <int>,
    "public-key": <int>
    ...  // другая публичная информация
}
```

#### server-file

Тип *server-file* используется для представления файлов на сервере. *server-file* должен содержать имя файла (поле `"name"`), токен, необходимый для скачивания файла (поле `"token"`) и размер файл в байтах (поле `size`).

```
{
    "name": <string>,
    "token": <string>,  // токен для скачивания файла
}
```

#### server-message

Тип *server-message* используется для представления уже отправленного пользовательского сообщения, хранящегося на сервере. *server-message* должно содержать *идентификатор* пользователей -отправителя и -получателя (поля `"sender"` и `"receiver"` соответсвенно), текст сообщения (поле `"text"`), время отправки сообщения (поле `"time"`). Если к сообщению приложены файлы, *server-message* должно содержать массив приложенных к сообщению файлов, представленных типом *server-file*. *server-message* может содержать другие поля (это определяется сервером). *server-message* иожет содеражать другие поля (это определяется сервером).

```
{
    "sender": <int>,
    "receiver": <int>,
    "text": <string>,
    "time": <unixtime>,
    "files":
    [
    	<server-file>,
    	...
    ]
}
```

#### client-file

Тип *client-file* представляет файл, который будет приложен к сообщению при его отправке на сервер. *client-file* должен содержать имя файла (поле `"name"`) и содержимое файла в формате *base64* (поле `"data"`). Имя может содержать:

- буквы латинского алфавита (в верхнем и нижнем регистре)
- десятичные цифры (0-9)
- пробел
- символ нижнего подчеркивания ("_")
- символ точки (".")

Имя не может заканчиваться точкой.

На имя и размер файла могут накладываться дополнительные ограничения (это определяется сервером).

```
{
    "name": <string>,
    "data": <string>
}
```

#### client-message

Тип *client-message* представляет пользовательское сообщение, которое будет отправлено на сервер. *client-mesage* должно содержать *идентификатор* получателя (полу `"receiver"`), текст сообщения (полк `"text"`), массив приложенных файлов, представленных типом *client-file*. Хотя бы одно из полей `"text"` и `"files"` должно быть непустым. *client-message* может содержать другие поля (это определяется сервером).

На длину сообщения и размер файлов могут накладываться дополнительные ограничения (это поределяется сервером).

```
{
    "text": <string>, 
    "files":  // по умолчанию - []
    [
    	<client-file>,
    	...
    ]
}
```

#### list-properties

Если ответ предполагает отправку массива значений, запрос может принимать аргумент типа *list-properties*. *list-properties* определяет, какую часть массива нужно отправить и в каком порядке. 

Поле `"count"` задаёт количество элементов массива, которое должен вернуть ответ. Если `"count"` не указан или значение `"count"` превышает максимально возможное, будет выбрано максимально возможное. 

Поле `"from"` определяет номер в массиве (с нуля), начиная с которого элементы будут добавляться в ответ. Если `"from"` не указан, берется значение `0`. Если `"from"` выходит за пределы массива, итоговый массив будет пуст.

Поле `"sort"` определяет, по какому критерию будут отсортированы элементы. Для каждого запроса возможные значения и значение по умолчанию поля `"sort"` указываются отдельно.

Поле `"filter"` указывает, что перед тем, как применить к массиву сортировку, в нем оставляются только определённые элементы массива. Если `"filter"` пуст или равен `null`,  то никакая фильтрация не применяется. Возможные значения `"filter"` для каждого запроса определяются отдельно.

Все запросы, принимающие в качестве аргумента значение типа *list-properties* должны предоставить значение по умолчанию каждому полю. В случае, если поле типа *list-properties* отсутствует, все значения должны считаться значением по умолчанию. 

```
{
    "from": <int>,
    "count": <int>,
    "sort": <string>,
    "filter": <string>,
    "is-ascending": <bool>
}
```

### Запросы клиента серверу

Ниже перечислены типы запросы, которые сервер обязан обрабатывать.

В случае, если сервер получил запрос не в формате `json`, сервер должен вернуть сообщение типа `"invalid-format"` с кодом ошибки `1`.

В случае, если сервер получил запрос, не содержащий поля `"type"`, сервер должен вернуть сообщение типа `"unspecified-type"` с кодом ошибки `1`.

В случае, если сообщение имеет неизвестный серверу тип, сервер должен выдать ошибку с кодом `1`.

Сервер может обрабатывать и другие типы запросов (это опеределяется сервером).

#### auth

Запрос типа `"auth"` осуществляет авторизацию пользователя. Авторизация пользователя должна быть проведена только один раз за подключение.

Запрос:

```
{
    "type": "auth",
    "args":
    {
        "login": <string>,
        "pass": <string>
    }
}
```

Ответ:

Возможные ошибки:

- Отсутствуют аргументы `"login"` или `"pass"` - 2
- Неверный логин или пароль - 4
- Попытка авторизоваться второй раз - 3

```
{
    "type": "auth",
    "status": <response-status>,
    "args":
    {
    	"id": <int>
	}
}
```

#### people-with-message

Запрос вида `"people-with-message"` возвращает массив пользователей, с которыми пользователь уже общался (то есть, существует сообщение от пользователя в массиве к текущему пользователю или наоборот) и последнее сообщение в беседе с этими пользователями.

Поля `"filter"`, `"sort"`, и `"is_ascending"` в `"list-properties"` игнорируются - пользователи не фильтруются, они упорядочены по времени отправки последнего сообщения в беседе с текущим пользователем (по убыванию). 

Запрос:

```
{
    "type": "people-with-message",
    "args":
    {
        "list-properties": <list-properties>,
    }
}
```

Ответ:

```
{
    "type": "people-with-message",
    "status": <response-status>,
    "args":
    {
        "chats":
        [
        	{
        		"user": <user>,
        		"last-message": <server-message>
    		},
        	...
        ]
    }
}
```

#### people

Запрос типа `"people" ` возвращает массив всех пользователей сети.

Возможные значения и значения по умолчанию полей `"filter"`, `"sort"`, и `"is_ascending"` в `"list-properties"` определяются сервером.

Запрос:

```
{
    "type": "people",
    "args":
    {
        "list-properties": <list-properties>
    }
}
```

Ответ:
Возможные ошибки:

- Неверное значение `"filter"` или `"sort"` в `"list-properties"` - 2

```
{
	"type": "people",
    "status": <response-status>,
	"args": 
	{
        "users":
        [
        	<user>,
        	...
        ]	
	}
}
```

#### messages

Запрос типа `"messages"` возвращает массив сообщений от одного пользователя.

Возможные значения и значения по умолчанию полей `"filter"`, `"sort"`, и `"is_ascending"` в `"list-properties"` определяются сервером.

 Запрос:

```
{
    "type": "messages",
    "args":
    {
        "user-id": <int>,
        "list-properties": <list-properties>,
    }
}
```

Ответ:

Возможные ошибки:

- Поле `"user-id"` отсутствует или его значение недействительно - 2
- Неверное значение `"filter"` или `"sort"` в `"list-properties"` - 2

```
{
	"type": "messages",
    "status": <response-status>,
    "args":
    {
        "messages": 
        [
        	<server-message>,  // отсортированы по времени отправления по убыванию
        	...
        ]
    }
}
```

#### send

Запрос типа `"send"` отправляет пользовательское сообщение другому пользователю.

Запрос:

```
{
	"type": "send",
    "args":
    {
        "receiver-id": <int>,
    	"message": <client-message>,
	}
}
```

Ответ:

Возможные ошибки:

- отсутствует одно из полей `"receiver-id"`, `"message"` или в `"receiver-id"` передан недействительный идентификатор - 2
- сообщение пусто или файлы в сообщении не соответствуют требованиям - 3 

```
{
    "type": "send",
    "status": <response-status>
}
```

#### get-user

Запрос типа `"get-user"` возвращает информацию о пользователе по его *идентификатору*.

Запрос:

```
{
    "type": "get-user",
    "args":
    {
        "id": <int>
    }
}
```

Ответ:

```
{
    "type": "get-user",
    "status": <response-status>,
    "args":
    {
        "user": <user>
    }
}
```

### События сервера

Ниже перечислены события, которые сервер должен отправлять клиентам.

Сервер может отправлять другие события (это определяется сервером).

#### message-received

Событие типа `"message-received"` отправляется пользователю, если он получил новое сообщение

```
{
    "type": "message-received",
    "args":
    {
        "message": <server-message>
    }
}
```
